<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on jean0t blog</title>
    <link>https://jean0t.github.io/posts/</link>
    <description>Recent content in Posts on jean0t blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Feb 2026 01:57:57 -0300</lastBuildDate>
    <atom:link href="https://jean0t.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OOP Is Not About Objects</title>
      <link>https://jean0t.github.io/posts/oop-is-not-about-objects/</link>
      <pubDate>Tue, 17 Feb 2026 01:57:57 -0300</pubDate>
      <guid>https://jean0t.github.io/posts/oop-is-not-about-objects/</guid>
      <description>&lt;h1 id=&#34;object-isnt-about-real-world-objects&#34;&gt;Object isn&amp;rsquo;t about real world Objects&lt;/h1&gt;&#xA;&lt;p&gt;The OOP paradigm in programming isn&amp;rsquo;t about modeling objects from real world with properties as we were told before, but about interfaces that communicate with each other. Interfaces are like contracts that tell what they offer you and what they must receive, the object answering it doesn&amp;rsquo;t matter much, which is the original concept from smalltalk that was the first to have this paradigm.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Awk Is Amazing</title>
      <link>https://jean0t.github.io/posts/awk-is-amazing/</link>
      <pubDate>Thu, 05 Feb 2026 22:15:41 -0300</pubDate>
      <guid>https://jean0t.github.io/posts/awk-is-amazing/</guid>
      <description>&lt;p&gt;Awk was created as a way to manipulate data easily because if you wanted to make some manipulation before, you had to create entire programs in C. As we know C isn&amp;rsquo;t the most complete language, it is really dry in the default library, which means that it would take a lot of time even for something simple, from that inconvenience that amazing tool was born.&lt;/p&gt;&#xA;&lt;h1 id=&#34;not-just-a-tool-but-a-programming-language-by-itself&#34;&gt;Not Just a Tool But a Programming Language By Itself&lt;/h1&gt;&#xA;&lt;p&gt;You can have files named &lt;code&gt;something.awk&lt;/code&gt; and it would be taken by the awk program and used to parse the input files, not to mention the possibility to create functions, having for loops and a great regex system.&lt;br&gt;&#xA;It considers the data from columns, you have the possibility to modify the separators and pretty much everything. Example of a function in awk:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simping for Common Lisp</title>
      <link>https://jean0t.github.io/posts/simping-for-common-lisp/</link>
      <pubDate>Thu, 29 Jan 2026 22:02:24 -0300</pubDate>
      <guid>https://jean0t.github.io/posts/simping-for-common-lisp/</guid>
      <description>&lt;h1 id=&#34;macros&#34;&gt;MACROS&lt;/h1&gt;&#xA;&lt;p&gt;That is the answer, simple and direct. Macros are the greatest tool regarding common lisp, it gives us more flexibility but also privacy.&lt;br&gt;&#xA;What do I mean by both terms &amp;lsquo;privacy&amp;rsquo; and &amp;lsquo;flexibility&amp;rsquo;?&lt;br&gt;&#xA;Privacy because it can hide functions in the package, you don&amp;rsquo;t need to expose your functions to make it work, just as you export a class with private methods, with macros you can expose simply an interface that will call those functions internally and be nice syntatically.&lt;br&gt;&#xA;Regarding flexibility it is also pretty direct, you don&amp;rsquo;t need to call functions everytime, you can make an structure that organizes the code itself with functions and other structures internally so you have a more coherent design and a DSL if you prefer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decoupling or Coupling That Is the Question</title>
      <link>https://jean0t.github.io/posts/decoupling-or-coupling-that-is-the-question/</link>
      <pubDate>Sat, 01 Nov 2025 21:02:20 -0300</pubDate>
      <guid>https://jean0t.github.io/posts/decoupling-or-coupling-that-is-the-question/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;introduction&lt;/h1&gt;&#xA;&lt;p&gt;Pretty much can be said regarding software architecture and trade offs and among all those things there is the so called structures we are all so used to hear about: clean architecture, onion or hexagonal architecture, etc. All of them are ways to organize the system according to how easy it is to modify/update and improve its scalability later.&lt;br&gt;&#xA;Among them, one idea that is recurrent is about decoupling, which is what we are going to discuss in this post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why Common Lisp Is My Favorite</title>
      <link>https://jean0t.github.io/posts/why-common-lisp-is-my-favorite/</link>
      <pubDate>Sat, 01 Nov 2025 00:37:00 -0300</pubDate>
      <guid>https://jean0t.github.io/posts/why-common-lisp-is-my-favorite/</guid>
      <description>&lt;p&gt;I came from a background of python/golang programming, my first contact with programming was with python, then I studied C to get to know systems programming and understand better about memory with pointers&amp;hellip; golang was kind of my favorite language during a lot of time, because it has a simple and direct syntax with some built in niceties like map or slices (which in C must be done manually).&lt;/p&gt;&#xA;&lt;p&gt;However after some time I got kinda bored, the tools were amazing but I didn&amp;rsquo;t feel the ecstasy of exploring new features or syntax, I had heard about lisp before, although I disregarded it because I thought it was esoteric (which was synonym of uselessly complex and hard) to do things.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
