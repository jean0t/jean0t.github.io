<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jean0t blog</title>
    <link>https://jean0t.github.io/</link>
    <description>Recent posts from jean0t blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>Joao Mauricio</managingEditor>
    
    <lastBuildDate>Thu, 29 Jan 2026 17:54:19 -0300</lastBuildDate>
    <atom:link href="https://jean0t.github.io/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>OOP Is Not About Objects</title>
      <link>https://jean0t.github.io/posts/oop-is-not-about-objects/</link>
      <pubDate>Tue, 17 Feb 2026 01:57:57 -0300</pubDate>
      <author>Joao Mauricio</author>
      <guid>https://jean0t.github.io/posts/oop-is-not-about-objects/</guid>
      <description>&lt;h1 id=&#34;object-isnt-about-real-world-objects&#34;&gt;Object isn&amp;rsquo;t about real world Objects&lt;/h1&gt;
&lt;p&gt;The OOP paradigm in programming isn&amp;rsquo;t about modeling objects from real world with properties as we were told before, but about interfaces that communicate with each other. Interfaces are like contracts that tell what they offer you and what they must receive, the object answering it doesn&amp;rsquo;t matter much, which is the original concept from smalltalk that was the first to have this paradigm.&lt;/p&gt;
&lt;h1 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h1&gt;
&lt;p&gt;One of the best ways to expose it is through golang interfaces.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Shape&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#a6e22e&#34;&gt;Perimeter&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sides&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we pass the type &lt;em&gt;Shape&lt;/em&gt; to a function, it doesn&amp;rsquo;t matter if the object is a triangle or square, the only thing that matters is the message being passed and the answer received.&lt;br&gt;
As I want to reinforce, It is the way it was intended to be as a paradigm. The Object was a template of how the messages would be processed and responded to, they worked the same as the interfaces we have today and it makes a lot of difference when programming and thinking about the result.&lt;/p&gt;
&lt;p&gt;The Object leaves the main point and you start thinking about the contract between them, you don&amp;rsquo;t model them after a &amp;rsquo;thing&amp;rsquo; that exists in real life, but as the behavior you expect to have accordingly to a certain message being received to be processed.&lt;br&gt;
Using the example of shapes, if you receive a message with 3 sides, you know it is a triangle, then the template regarding triangle (the object) will take this information and work on it&amp;hellip; same if it was 4 sides, you would use the rectangle object&amp;hellip;&lt;/p&gt;
&lt;p&gt;What we have today, that is basically highlighting the objects and classes so much, is due to the inheritance of java. It being used as a standard way to learn OOP brought a lot of weird thoughts regarding this paradigm and how it should work. I too was really confused about it because of the usual and lazy explanations, so I am writing about it to clarify and bring this perspective into light.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Awk Is Amazing</title>
      <link>https://jean0t.github.io/posts/awk-is-amazing/</link>
      <pubDate>Thu, 05 Feb 2026 22:15:41 -0300</pubDate>
      <author>Joao Mauricio</author>
      <guid>https://jean0t.github.io/posts/awk-is-amazing/</guid>
      <description>&lt;p&gt;Awk was created as a way to manipulate data easily because if you wanted to make some manipulation before, you had to create entire programs in C. As we know C isn&amp;rsquo;t the most complete language, it is really dry in the default library, which means that it would take a lot of time even for something simple, from that inconvenience that amazing tool was born.&lt;/p&gt;
&lt;h1 id=&#34;not-just-a-tool-but-a-programming-language-by-itself&#34;&gt;Not Just a Tool But a Programming Language By Itself&lt;/h1&gt;
&lt;p&gt;You can have files named &lt;code&gt;something.awk&lt;/code&gt; and it would be taken by the awk program and used to parse the input files, not to mention the possibility to create functions, having for loops and a great regex system.&lt;br&gt;
It considers the data from columns, you have the possibility to modify the separators and pretty much everything. Example of a function in awk:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;awk &amp;#39;
    # this code lists every user with /bin/bash
    # as the default shell

    function endsWith(text, suffix) {
        return text ~ prefix&amp;#34;$&amp;#34;
    }
    BEGIN { FS = &amp;#34;:&amp;#34; }
    endsWith($7, &amp;#34;bash&amp;#34;) { print $0 }
&amp;#39; /etc/passwd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It has comments with # and a structure pretty well defined, you have 2 basic statements, &lt;strong&gt;BEGIN&lt;/strong&gt; and &lt;strong&gt;END&lt;/strong&gt;, one runs before everything, which you use to configure separators and all variables, the other runs when everything finishes, which you can use to make some substitution or anything else you find useful to run in the end.&lt;/p&gt;
&lt;h1 id=&#34;why-would-you-use-it&#34;&gt;Why Would You Use It?&lt;/h1&gt;
&lt;p&gt;You can use one liners from perl, python or any programming language that is interpreted and can run in command line, but trust me, it wont be as directly and nice as awk. Not to mention that with bash, awk is the only second program you can be 100% sure of existing in any distribution, even alpine has it.&lt;br&gt;
If you want to know a posix tool that will help you create scripts that are sure to run in any environment, it can be a great investment of time to upgrade your skills as system administrator or simply to satisfy a curiosity like me.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simping for Common Lisp</title>
      <link>https://jean0t.github.io/posts/simping-for-common-lisp/</link>
      <pubDate>Thu, 29 Jan 2026 22:02:24 -0300</pubDate>
      <author>Joao Mauricio</author>
      <guid>https://jean0t.github.io/posts/simping-for-common-lisp/</guid>
      <description>&lt;h1 id=&#34;macros&#34;&gt;MACROS&lt;/h1&gt;
&lt;p&gt;That is the answer, simple and direct. Macros are the greatest tool regarding common lisp, it gives us more flexibility but also privacy.&lt;br&gt;
What do I mean by both terms &amp;lsquo;privacy&amp;rsquo; and &amp;lsquo;flexibility&amp;rsquo;?&lt;br&gt;
Privacy because it can hide functions in the package, you don&amp;rsquo;t need to expose your functions to make it work, just as you export a class with private methods, with macros you can expose simply an interface that will call those functions internally and be nice syntatically.&lt;br&gt;
Regarding flexibility it is also pretty direct, you don&amp;rsquo;t need to call functions everytime, you can make an structure that organizes the code itself with functions and other structures internally so you have a more coherent design and a DSL if you prefer.&lt;/p&gt;
&lt;p&gt;Imagine you have a module to graphics that you want to expose to the public, if it was in C you would create a header files with all the functions available there, but in Common Lisp you can create a macro that can be like:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(draw-line :x1 0 :y1 120 :x2 100 :y2 400)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What it does? It draws a line from the coordinates (0, 120) to (100, 400). It has a nice design over it, the name is self explanatory and the elements are really descritive.&lt;br&gt;
It is also great when you know it has no penality in speed whatsoever, the internal functions will be called and coordinated to make this happen while you simply talk with this interface.&lt;/p&gt;
&lt;h1 id=&#34;ffi-with-c&#34;&gt;FFI with C&lt;/h1&gt;
&lt;p&gt;The FFI interface with the C ABI is incredible. If you come from the background of C++ that you can use interchangeable or even D that you simply need to rewrite the header of the function to use it, you will find it pretty simple and easy. We have the native way of sbcl that is the package &lt;code&gt;sb-alien&lt;/code&gt;, but also the cool way that is the cffi library that handles the heavy lifting nicely.&lt;br&gt;
The way to make it work is to declare exactly like C, the types used and the signature of the functions, which can be time consuming, but rewards us with more control over the code. The cffi can define enums, structs, pointers and everything else without much trouble, like in this example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// the C code:
int add(a int, b int) {
    return a + b;
}

//===================
; the lisp version with cffi:
; the name %add is the name we give the function ourselves
(cffi:defcfun (&amp;#34;add&amp;#34; %add) :int
  (a :int)
  (b :int))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See? Really simple, we even have &lt;code&gt;cffi:defcenum&lt;/code&gt; and other niceties.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decoupling or Coupling That Is the Question</title>
      <link>https://jean0t.github.io/posts/decoupling-or-coupling-that-is-the-question/</link>
      <pubDate>Sat, 01 Nov 2025 21:02:20 -0300</pubDate>
      <author>Joao Mauricio</author>
      <guid>https://jean0t.github.io/posts/decoupling-or-coupling-that-is-the-question/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;introduction&lt;/h1&gt;
&lt;p&gt;Pretty much can be said regarding software architecture and trade offs and among all those things there is the so called structures we are all so used to hear about: clean architecture, onion or hexagonal architecture, etc. All of them are ways to organize the system according to how easy it is to modify/update and improve its scalability later.&lt;br&gt;
Among them, one idea that is recurrent is about decoupling, which is what we are going to discuss in this post.&lt;/p&gt;
&lt;h1 id=&#34;clean-architecture-and-decoupling&#34;&gt;Clean architecture and decoupling&lt;/h1&gt;
&lt;p&gt;When we talk about architecture, clean architecture is one that I like the most, because a personal preference of mine is coding monoliths instead of microservices. This arrangement makes the program as layers (which resembles the onion architecture), each of them is independent from the level above and dependent of only the level immediately below it. As a general rule we have:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;models -&amp;gt; repository -&amp;gt; services -&amp;gt; presentation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;models is the raw database configuration, the most internal levels, repository deals with persistence and services deals with the verifications and operations, presentation is basically the external utilisation, like api calls or a cli interface&amp;hellip; gui or tui&amp;hellip; basically the interface that will permit the user interact with the software.&lt;br&gt;
After this brief explanation we can see that each layer is responsible for one thing and they are decoupled in the sense that we can change only one of them and the others will remain mostly untouched, which is the magic of decoupling, easiness of modifications, which inspired microservices that takes it to another level of decoupling by separating logic itself in micro APIs inside a major API.&lt;/p&gt;
&lt;h1 id=&#34;is-decoupling-the-magic-solution-and-coupling-really-bad&#34;&gt;Is decoupling the magic solution and coupling really bad?&lt;/h1&gt;
&lt;p&gt;That is what I thought when I was reflecting about django, django orm, decoupling and microservices. If decoupling is really that good, what about frameworks like django that have everything integrated and dependence isn&amp;rsquo;t really a choice? Because if you need to change anything you will have a lot more of effort to do anything, so what do we get as advantage to have that? Practicality and speed! Two factors that are really important depending on the project.&lt;br&gt;
The more I thought about it, the more I saw that the answer is depends and that there is nothing wrong with depending on a framework that is as reliable as django, like&amp;hellip; no one would doubt that making a full application on rails is a bad idea nor it is with laravel.&lt;/p&gt;
&lt;h1 id=&#34;magic-doesnt-exists-but-possibilities&#34;&gt;Magic doesn&amp;rsquo;t exists but possibilities&lt;/h1&gt;
&lt;p&gt;I see those architectures as possibilities, a way to think about our applications. Some people like to decouple and make the modules as independent as possible, even if it means by exaggerating in micro services or making hundreds of directories to separate scopes. Decoupling is great when you are in an unstable environment where you don&amp;rsquo;t know if the tech stack might change or the framework isn&amp;rsquo;t batteries included and each part depends in a different external module, but when we have a complete framework like django, sometimes this trade off isn&amp;rsquo;t that bad even if it means becoming dependent of something.&lt;br&gt;
What we have isn&amp;rsquo;t a silver bullet that work for everything but directions that we can take or adapt to our own reality.&lt;br&gt;
Like interfaces, they are great to make a common ground of interaction, but if you exagerate they can make the code worse.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Decoupling or dependence isn&amp;rsquo;t inherently bad, just have a common sense and critical thinking to adapt the concepts and think outside the paradigm of your language, if possible to have a wider vision regarding a challenge, sometimes what we are preached about isn&amp;rsquo;t wrong, but depending on the situation it isn&amp;rsquo;t really convenient or the ideal solution.&lt;br&gt;
Sometimes the best trade off is to complete the solution faster and with a known model, like those batteries included frameworks, without having to recreate everything with build-as-you-go frameworks that you also need to use a lot of time to think about the architecture.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Common Lisp Is My Favorite</title>
      <link>https://jean0t.github.io/posts/why-common-lisp-is-my-favorite/</link>
      <pubDate>Sat, 01 Nov 2025 00:37:00 -0300</pubDate>
      <author>Joao Mauricio</author>
      <guid>https://jean0t.github.io/posts/why-common-lisp-is-my-favorite/</guid>
      <description>&lt;p&gt;I came from a background of python/golang programming, my first contact with programming was with python, then I studied C to get to know systems programming and understand better about memory with pointers&amp;hellip; golang was kind of my favorite language during a lot of time, because it has a simple and direct syntax with some built in niceties like map or slices (which in C must be done manually).&lt;/p&gt;
&lt;p&gt;However after some time I got kinda bored, the tools were amazing but I didn&amp;rsquo;t feel the ecstasy of exploring new features or syntax, I had heard about lisp before, although I disregarded it because I thought it was esoteric (which was synonym of uselessly complex and hard) to do things.&lt;/p&gt;
&lt;p&gt;Some hours with it proved me how wrong I was&amp;hellip;&lt;/p&gt;
&lt;h4 id=&#34;why-it-is-so-good&#34;&gt;Why it is so good?&lt;/h4&gt;
&lt;p&gt;As previously menitoned, I like simple and direct languages, but I also love to explore new syntaxes and ways of working. Lisp is a definition, which means a lot of &amp;lsquo;dialects&amp;rsquo; of it exist, each with its functions, modules and uses.&lt;br&gt;
However that is one of its best features and how it shiny: the previsibility and stability. Its syntax is the same, no matter the dialect you will always have the basic:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(function arg1 arg2 ... argN)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What will change is the underlying implementation, like being case sensitive or separating the namespace of functions and arguments.&lt;br&gt;
Another aspect that made me think it is magical is it pragmaticality, its debug is powerful, we can change variables and functions while it is &lt;strong&gt;still&lt;/strong&gt; executing!!!&lt;br&gt;
Related to this interactive debug comes the fact lisp is interpreted, but forget your concept about slow languages like python/ruby or memory eater like javascript, Lisp is fast, lightweight and offers compilation, sometimes native compilation binary depending on the lisp implementation you are using.&lt;br&gt;
Famous versions of lisp are: emacs lisp, lisp flavored erlang, clojure, common lisp, scheme, guile, etc.&lt;/p&gt;
&lt;p&gt;And I didn&amp;rsquo;t even mentioned the powerful system of macros that can literally implement new paradigms to the language.&lt;/p&gt;
&lt;h5 id=&#34;common-lisp-is-reliable-powerful-fast-dynamic-customizable-and-multiple-just-choose-the-version-you-love-and-dive-in&#34;&gt;Common lisp is reliable, powerful, fast, dynamic, customizable and multiple. Just choose the version you love and dive in.&lt;/h5&gt;
</description>
    </item>
    
  </channel>
</rss>
